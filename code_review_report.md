# コンパイラプロジェクト コードレビューレポート

## 1. 総評 (Executive Summary)

全体として、このコンパイラプロジェクトは非常にクリーンなコードで書かれており、優れた設計の基盤を持っています。特にパーサーとエラーハンドリングの設計は堅牢かつ拡張性が高く、今後の開発の強固な土台となるでしょう。

現時点での最も重要な課題は、**コード生成器 (`codegen`) が特定のアーキテクチャ (ARM64) に密結合している点**です。この設計は、目標であるC言語コンパイラとして多アーキテクチャをサポートする上で、将来的なスケールを妨げる大きな技術的負債となります。

以下に、各コンポーネントの詳細なレビュー結果と、根本的な課題、そして推奨される改善策を記述します。

---

## 2. 詳細レビュー

### 2.1. コードスタイル

**評価: 非常に良い**

-   **フォーマット**: `rustfmt.toml`による一貫したフォーマットが適用されています。
-   **命名規則**: Rustの標準的な命名規則に準拠しており、可読性が高いです。
-   **ドキュメント**: `Parser`構造体には詳細なドキュメンテーションコメントが付与されており、プロジェクトの理解を助けています。

**結論**: コードスタイルはプロジェクト全体で一貫しており、問題ありません。

### 2.2. 構文解析器とAST (`parser.rs`, `ast.rs`)

**評価: 非常に良い**

-   **設計**: 文法には再帰下降、式にはPratt (Precedence Climbing) パーサーを採用しており、これは構文解析におけるベストプラクティスです。ASTの構造も直感的で理解しやすいです。
-   **変更容易性**: 新しい演算子や構文を追加する際の拡張性が非常に高い設計です。例えば、新しい二項演算子を追加する場合、`token.rs`と`ast.rs`の数カ所を変更するだけで、パーサーロジックの主要部分に手を加える必要はありません。
-   **認知負荷**: Prattパーサーのアルゴリズムを知っていれば、コードは非常に素直で理解しやすいです。

**提案 (軽微)**:
-   `parser.rs`の`expr`メソッド内に、Prattパーサーの動作原理（特に優先順位の扱い方）について簡単なコメントを追加すると、このアルゴリズムに不慣れな開発者の理解をさらに促進できます。

### 2.3. エラーハンドリング (`error.rs`)

**評価: 非常に良い**

-   **設計**: `CompilerError` enumでエラー型を集約し、`Spanned`トレイトでエラー箇所を抽象化している点は、非常に優れた設計です。
-   **ユーザー体験**: `format_error`関数により、エラー箇所がソースコード上で明確に示されるため、非常にユーザーフレンドリーです。

**結論**: エラーハンドリングの仕組みは堅牢で拡張性も高く、現時点で修正すべき点はありません。

### 2.4. コード生成器 (`codegen.rs`)

**評価: 要改善**

-   **設計**: ASTを直接トラバースしてARM64のアセンブリ文字列を生成する現在の実装は、シンプルで直感的ですが、アーキテクチャとの結合度が極めて高いです。
-   **変更容易性**: **対応アーキテクチャの追加（例: x86-64）が、現在の設計ではほぼ不可能です。** `if/else`でターゲットを分岐させる方法はコードを著しく複雑化させ、ファイルを複製する方法は保守の悪夢となります。
-   **バグ**: `if`文のラベル生成が一意でないため、ネストした`if`文でバグが発生します。(`TODO`にも記載あり)
-   **コードの重複**: 多くの二項演算子で、スタック操作の定型的なアセンブリコードが重複しています。

**結論**: コード生成器は、現在のプロジェクトにおける最も改善が必要なコンポーネントです。

### 2.5. テスト (`main.rs`)

**評価: 要改善**

- **テストの破損**: `cargo test` を実行したところ、テストがコンパイルエラーで失敗することを確認しました。テストコード内で使用されている `Evaluator` というコンポーネントが見つからないことが原因です。
- **影響**: これにより、コードの変更時にリグレッションを自動で検出することができず、品質保証が困難になっています。`Evaluator` はASTを直接実行するテスト用のコンポーネントだったと推測されますが、これが削除された際にテストコードが更新されなかったようです。

**結論**: テストが機能していないことは、プロジェクトの健全性における重大な問題です。コード生成器のリファクタリングと並行して、テストの修正は最優先で取り組むべき課題です。


---

## 3. 根本的な課題と推奨される改善策

レビューの結果、発見された個別の問題点を統合し、よりメタレベルの課題として以下を特定しました。

### 根本的な課題: バックエンドの責務分離の欠如

現在のコード生成器は、「ASTをどのように辿るか」というロジックと、「特定の命令をどのように生成するか」というアーキテクチャ固有のロジックが完全に一体化しています。これが、前述した変更容易性の低さの根本的な原因です。

プロジェクトがC言語コンパイラとしてスケールするためには、この2つの責務を明確に分離し、**バックエンドを交換可能 (pluggable) にする**必要があります。

### 推奨される改善ロードマップ

以下の段階的な改善を提案します。

**Step 1: ラベル生成器の導入 (短期・必須)**

-   まず、現在のバグを修正するために、一意なラベル（例: `.L1`, `.L2`, ...）を生成するコンポーネントを作成し、`CodeGenerator`に持たせます。

**Step 2: バックエンドの抽象化 (中期・重要)**

-   アーキテクチャ固有の操作を抽象化する`Backend`トレイトを定義します。
    ```rust
    trait Backend {
        // スタック操作
        fn push(&mut self, register: &str);
        fn pop(&mut self, register: &str);

        // 算術演算
        fn gen_add(&mut self);
        fn gen_sub(&mut self);
        // ...

        // 制御フロー
        fn gen_label(&mut self, label: &str);
        fn gen_conditional_jump(&mut self, label: &str);
        // ...
    }
    ```
-   現在の`codegen.rs`のロジックを、この`Backend`トレイトを実装した`Arm64Backend`に移動させます。
-   `CodeGenerator`は、アセンブリ文字列を直接生成する代わりに、`Backend`トレイトのメソッドを呼び出すようにリファクタリングします。

このリファクタリングにより、`CodeGenerator`はASTのトラバーサルに専念し、アーキテクチャの詳細は`Arm64Backend`に隠蔽されます。将来x86-64に対応する際は、`X86Backend`を新たに追加するだけで済み、`CodeGenerator`の主要ロジックを変更する必要がなくなります。

**Step 3: 中間表現 (IR) の導入 (長期・任意)**

-   さらなる最適化や高度な言語機能（例: 関数呼び出しのABI準拠）を実装する段階では、ASTから直接アセンブリを生成するのではなく、間にターゲット非依存の**中間表現 (IR)** を挟むことを検討します。
-   `[AST] -> [IR] -> [Assembly]` という多段構成にすることで、最適化処理をIRに対して一度だけ実装すれば、全ターゲットアーキテクチャでその恩恵を受けられるようになります。

まずは**Step 1**と**Step 2**に取り組むことで、プロジェクトは将来の拡張に対する堅牢なアーキテクチャを獲得できるでしょう。
